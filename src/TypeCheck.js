// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Js_dict from "bs-platform/lib/es6/js_dict.js";
import * as Js_json from "bs-platform/lib/es6/js_json.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Styp$ReactTemplate from "./Styp.js";

var defaultMode = /* record */[/* singletonTypes */false];

function fromJson($staropt$star, json) {
  var mode = $staropt$star !== undefined ? $staropt$star : defaultMode;
  var match = Js_json.classify(json);
  if (typeof match === "number") {
    switch (match) {
      case /* JSONFalse */0 :
          var match$1 = mode[/* singletonTypes */0];
          return /* record */[
                  /* typ : Boolean */Block.__(3, [match$1 ? false : undefined]),
                  /* o : NotOpt */0,
                  /* p */Styp$ReactTemplate.P.one
                ];
      case /* JSONTrue */1 :
          var match$2 = mode[/* singletonTypes */0];
          return /* record */[
                  /* typ : Boolean */Block.__(3, [match$2 ? true : undefined]),
                  /* o : NotOpt */0,
                  /* p */Styp$ReactTemplate.P.one
                ];
      case /* JSONNull */2 :
          return /* record */[
                  /* typ : Empty */0,
                  /* o : Opt */[Styp$ReactTemplate.P.one],
                  /* p */Styp$ReactTemplate.P.one
                ];
      
    }
  } else {
    switch (match.tag | 0) {
      case /* JSONString */0 :
          var match$3 = mode[/* singletonTypes */0];
          return /* record */[
                  /* typ : String */Block.__(2, [match$3 ? match[0] : undefined]),
                  /* o : NotOpt */0,
                  /* p */Styp$ReactTemplate.P.one
                ];
      case /* JSONNumber */1 :
          var match$4 = mode[/* singletonTypes */0];
          return /* record */[
                  /* typ : Number */Block.__(1, [match$4 ? match[0] : undefined]),
                  /* o : NotOpt */0,
                  /* p */Styp$ReactTemplate.P.one
                ];
      case /* JSONObject */2 :
          var do_entry = function (param) {
            var styp = fromJson(mode, param[1]);
            return /* tuple */[
                    param[0],
                    styp
                  ];
          };
          return /* record */[
                  /* typ */Styp$ReactTemplate.makeObject(Belt_Array.map(Js_dict.entries(match[0]), do_entry)),
                  /* o : NotOpt */0,
                  /* p */Styp$ReactTemplate.P.one
                ];
      case /* JSONArray */3 :
          var styp = Belt_Array.reduce(match[0], /* record */[
                /* typ : Empty */0,
                /* o : NotOpt */0,
                /* p */Styp$ReactTemplate.P.zero
              ], (function (styp, json) {
                  return plusStyp(styp, fromJson(mode, json));
                }));
          return /* record */[
                  /* typ : Array */Block.__(5, [styp]),
                  /* o : NotOpt */0,
                  /* p */Styp$ReactTemplate.P.one
                ];
      
    }
  }
}

function plusStyp(styp1, styp2) {
  var match = plusTyp(styp1[/* typ */0], styp2[/* typ */0]);
  var typ = match !== undefined ? match : plusUnion(Styp$ReactTemplate.stypToUnion(styp1), Styp$ReactTemplate.stypToUnion(styp2));
  var o = plusO(styp1[/* o */1], styp2[/* o */1]);
  var p = Styp$ReactTemplate.P["^"](styp1[/* p */2], styp2[/* p */2]);
  return /* record */[
          /* typ */typ,
          /* o */o,
          /* p */p
        ];
}

function plusTyp(_typ1, _typ2) {
  while(true) {
    var typ2 = _typ2;
    var typ1 = _typ1;
    var exit = 0;
    var exit$1 = 0;
    if (typeof typ1 === "number") {
      exit$1 = 3;
    } else {
      switch (typ1.tag | 0) {
        case /* Number */1 :
            var x = typ1[0];
            if (typeof typ2 === "number") {
              exit = 2;
            } else {
              switch (typ2.tag | 0) {
                case /* Number */1 :
                    var match = Caml_obj.caml_equal(x, typ2[0]);
                    if (match) {
                      return /* Number */Block.__(1, [x]);
                    } else {
                      return ;
                    }
                case /* Array */5 :
                    return ;
                case /* Diff */7 :
                    exit$1 = 3;
                    break;
                default:
                  
              }
            }
            break;
        case /* String */2 :
            var x$1 = typ1[0];
            if (typeof typ2 === "number") {
              exit = 2;
            } else {
              switch (typ2.tag | 0) {
                case /* String */2 :
                    var match$1 = Caml_obj.caml_equal(x$1, typ2[0]);
                    if (match$1) {
                      return /* String */Block.__(2, [x$1]);
                    } else {
                      return ;
                    }
                case /* Array */5 :
                    return ;
                case /* Diff */7 :
                    exit$1 = 3;
                    break;
                default:
                  
              }
            }
            break;
        case /* Boolean */3 :
            var x$2 = typ1[0];
            if (typeof typ2 === "number") {
              exit = 2;
            } else {
              switch (typ2.tag | 0) {
                case /* Boolean */3 :
                    var match$2 = Caml_obj.caml_equal(x$2, typ2[0]);
                    if (match$2) {
                      return /* Boolean */Block.__(3, [x$2]);
                    } else {
                      return ;
                    }
                case /* Array */5 :
                    return ;
                case /* Diff */7 :
                    exit$1 = 3;
                    break;
                default:
                  
              }
            }
            break;
        case /* Object */4 :
            if (typeof typ2 === "number") {
              exit = 2;
            } else {
              switch (typ2.tag | 0) {
                case /* Object */4 :
                    var d = { };
                    var doItem = (function(d){
                    return function doItem(param) {
                      var styp = param[1];
                      var lbl = param[0];
                      var match = Js_dict.get(d, lbl);
                      if (match !== undefined) {
                        d[lbl] = plusStyp(styp, match);
                        return /* () */0;
                      } else {
                        d[lbl] = styp;
                        return /* () */0;
                      }
                    }
                    }(d));
                    Belt_Array.forEach(Js_dict.entries(typ1[0]), doItem);
                    Belt_Array.forEach(Js_dict.entries(typ2[0]), doItem);
                    return Styp$ReactTemplate.makeObject(Js_dict.entries(d));
                case /* Array */5 :
                    return ;
                case /* Diff */7 :
                    exit$1 = 3;
                    break;
                default:
                  
              }
            }
            break;
        case /* Array */5 :
            if (typeof typ2 === "number") {
              exit = 2;
            } else {
              switch (typ2.tag | 0) {
                case /* Array */5 :
                    return /* Array */Block.__(5, [plusStyp(typ1[0], typ2[0])]);
                case /* Diff */7 :
                    exit$1 = 3;
                    break;
                default:
                  
              }
            }
            break;
        case /* Diff */7 :
            _typ1 = typ1[0];
            continue ;
        default:
          exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      if (typeof typ2 === "number") {
        if (typeof typ1 === "number") {
          return typ2;
        } else {
          exit = 2;
        }
      } else if (typ2.tag === /* Diff */7) {
        _typ2 = typ2[0];
        continue ;
      } else if (typeof typ1 === "number") {
        return typ2;
      } else {
        exit = 2;
      }
    }
    if (exit === 2) {
      if (typeof typ2 === "number") {
        return typ1;
      } else if (typeof typ1 !== "number" && !typ1.tag) {
        _typ2 = typ1[0];
        _typ1 = typ2;
        continue ;
      }
      
    }
    if (typeof typ2 === "number") {
      return ;
    } else {
      switch (typ2.tag | 0) {
        case /* Same */0 :
            _typ2 = typ2[0];
            continue ;
        case /* Array */5 :
            return ;
        default:
          return ;
      }
    }
  };
}

function plusUnion(styps1, styps2) {
  var findMatch = function (t, _ts, _acc) {
    while(true) {
      var acc = _acc;
      var ts = _ts;
      if (ts) {
        var ts1 = ts[1];
        var t1 = ts[0];
        if (plusTyp(t[/* typ */0], t1[/* typ */0]) !== undefined) {
          return /* tuple */[
                  t1,
                  Belt_List.concat(Belt_List.reverse(acc), ts1)
                ];
        } else {
          _acc = /* :: */[
            t1,
            acc
          ];
          _ts = ts1;
          continue ;
        }
      } else {
        return ;
      }
    };
  };
  var plus = function (ls1, ls2) {
    if (ls1) {
      var ts1 = ls1[1];
      var t1 = ls1[0];
      var match = findMatch(t1, ls2, /* [] */0);
      if (match !== undefined) {
        var match$1 = match;
        return /* :: */[
                plusStyp(t1, match$1[0]),
                plus(ts1, match$1[1])
              ];
      } else {
        return /* :: */[
                t1,
                plus(ts1, ls2)
              ];
      }
    } else {
      return ls2;
    }
  };
  return Styp$ReactTemplate.makeUnion(plus(styps1, styps2));
}

function plusO(o1, o2) {
  if (o1) {
    if (o2) {
      return /* Opt */[Styp$ReactTemplate.P["^"](o1[0], o2[0])];
    } else {
      return o1;
    }
  } else {
    return o2;
  }
}

var $caret = plusStyp;

var singletonMode = /* record */[/* singletonTypes */true];

export {
  defaultMode ,
  singletonMode ,
  fromJson ,
  plusStyp ,
  plusO ,
  plusTyp ,
  plusUnion ,
  $caret ,
  
}
/* No side effect */
